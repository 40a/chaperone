#!/usr/bin/python3
# -*- mode: python -*-

"""
Lightweight process and service manager

Usage:
    chaperone [--user=<name>]
              [--config=<file_or_dir>] 
              [--shutdown_on_exit] [--nodelay] [--debug]
              [<command> [<args> ...]]

Options:
    -v                       Provide verbose messages
    --user=<name>            Start first process as user (else root)
    --config=<file_or_dir>   Specifies file or directory for configuration [default: /etc/chaperone.d]
    --shutdown_on_exit       If set, then the entire system will be shutdown when the given command (if any)
                             terminates.
    --nodelay                Eliminates delay before initial command prompt when there are services.
    --debug                  Turn on debugging features

If a user is specified, then the basename of file_or_dir is searched in the user's directory, and it
must be owned by the user to take effect.
"""

import logging
logging.basicConfig()

import sys
import os
import asyncio
from functools import partial
from docopt import docopt

# Assure that packages in the same directory as ours (bin) can be used without concern for where
# we are installed
sys.path[0] = os.path.dirname(sys.path[0])

from cutil.logging import warn, info, set_log_level
from cproc import TopLevelProcess
from cutil.config import Configuration

options = docopt(__doc__, options_first=True)
if options['--debug']:
   set_log_level(logging.DEBUG)
   print('OPTIONS', options)

tlp = TopLevelProcess.sharedInstance()
if options['--debug']:
   tlp.debug = True

cmd = options['<command>']

config = Configuration.configFromCommandSpec(options['--config'], user=options['--user'])

@asyncio.coroutine
def run_command():
   sproc = tlp.run([cmd] + options['<args>'], user=(options.get('--user')), wait=True)
   yield from sproc
   if options['--shutdown_on_exit']:
      tlp.kill_system()

services = tlp.run_services(config)
tlp.activate(services)

if cmd:
   if services and not options['--nodelay']:
      tlp.loop.call_later(1, lambda: tlp.activate(run_command()))
   else:
      tlp.loop.call_soon(lambda: tlp.activate(run_command()))
 
tlp.run_event_loop()
